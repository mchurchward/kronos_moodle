<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Kronos virtual machine request web service.
 *
 * @package    auth_kronosportal
 * @author     Remote-Learner.net Inc
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 * @copyright  (C) 2015 Remote Learner.net Inc http://www.remote-learner.net
 */

require_once($CFG->libdir."/externallib.php");
require_once($CFG->dirroot."/auth/kronosportal/lib.php");

/**
 * Authentication plugin to provide single sign on with a token generated by
 * a web service
 */
class auth_kronosportal_external extends external_api {

    /**
     * Returns description of method parameters for create_token
     *
     * @return external_function_parameters
     */
    public static function create_token_parameters() {
        return new external_function_parameters(array(
            'username' => new external_value(PARAM_USERNAME, 'The username to create the token for'),
            'firstname' => new external_value(PARAM_TEXT, 'First name', VALUE_DEFAULT),
            'lastname' => new external_value(PARAM_TEXT, 'Last name', VALUE_DEFAULT),
            'solutionid' => new external_value(PARAM_TEXT, 'Solution ID/Customer ID', VALUE_DEFAULT),
            'password' => new external_value(PARAM_TEXT, 'Password', VALUE_DEFAULT),
            'email' => new external_value(PARAM_EMAIL, 'Email', VALUE_DEFAULT),
            'city' => new external_value(PARAM_TEXT, 'City', VALUE_DEFAULT),
            'country' => new external_value(PARAM_TEXT, 'Country', VALUE_DEFAULT),
            'language' => new external_value(PARAM_TEXT, 'Language', VALUE_DEFAULT),
            'learningpath' => new external_value(PARAM_TEXT, 'learningPath', VALUE_DEFAULT)
        ));
    }

    /**
     * Creates token associated with username to be used for single sign-on
     *
     * @throws moodle_exception On missing data or invalid user data.
     * @param string $username The username to create token for.
     * @return string $token the single sign on token.
     */
    public static function create_token($username, $firstname = null, $lastname = null, $solutionid = null, $password = null,
            $email = null, $city = null, $country = null, $language = 'en_utf8', $learningpath = null) {
        global $DB;
        $usertoken = $DB->get_record('user', array('username' => $username));
        if (empty($usertoken)) {
            $result = self::create_user($username, $firstname, $lastname, $solutionid,
                    $password, $email, $city, $country, $language, $learningpath);
            $usertoken = $DB->get_record('user', array('username' => $username));
            if (empty($usertoken)) {
                throw new invalid_parameter_exception(get_string('webserviceerrorinvaliduser', 'auth_kronosportal'));
            }
        } else {
            $args = func_get_args();
            $update = false;
            $total = count($args);
            for ($i = 1; $i < $total; $i++) {
                if (!empty($args[$i])) {
                    $update = true;
                }
            }
            if ($update) {
                // As par KRONOSDEV-73, the client has requested to not have the city and country updated via the create_token web service.
                $city = null;
                $country = null;
                $result = self::update_user($username, $firstname, $lastname, $solutionid, $password,
                        $email, $city, $country, $language, $learningpath);
            }
        }

        $token = self::generate_token();
        $record = new stdClass();
        $record->userid = $usertoken->id;
        $record->token = $token;
        $record->timecreated = time();
        $DB->insert_record('kronosportal_tokens', $record);

        return array(
            'status' => 'success',
            'token' => $token,
            'userid' => $usertoken->id
        );
    }

    /**
     * Returns description of create_token return value
     *
     * @return external_description
     */
    public static function create_token_returns() {
        return new external_single_structure(array(
            'status' => new external_value(PARAM_TEXT, 'Returns success when token is created.'),
            'token' => new external_value(PARAM_TEXT, 'sso token', VALUE_OPTIONAL),
            'userid' => new external_value(PARAM_INT, 'User id of user.')
        ));
    }

    /**
     * Returns description of method parameters for create_user
     *
     * @return external_function_parameters
     */
    public static function create_user_parameters() {
        return new external_function_parameters(array(
            'username' => new external_value(PARAM_USERNAME, 'The username to create'),
            'firstname' => new external_value(PARAM_TEXT, 'First name'),
            'lastname' => new external_value(PARAM_TEXT, 'Last name'),
            'solutionid' => new external_value(PARAM_TEXT, 'Solution ID/Customer ID'),
            'password' => new external_value(PARAM_TEXT, 'Password'),
            'email' => new external_value(PARAM_EMAIL, 'Email'),
            'city' => new external_value(PARAM_TEXT, 'City', VALUE_DEFAULT),
            'country' => new external_value(PARAM_TEXT, 'Country', VALUE_DEFAULT),
            'language' => new external_value(PARAM_TEXT, 'Language', VALUE_DEFAULT),
            'learningpath' => new external_value(PARAM_TEXT, 'learningPath', VALUE_DEFAULT)
        ));
    }

    /**
     * Creates user and assigns custom profile fiels only if solution id is active.
     *
     * @throws moodle_exception On missing data or invalid user data or user exists.
     * @param string $username The username to create token for.
     * @return array Return status and userid.
     */
    public static function create_user($username, $firstname, $lastname, $solutionid, $password,
            $email, $city = '', $country = '', $language = '', $learningpath = null) {
        global $DB, $CFG;
        if ($language == '') {
            $language = $CFG->lang;
        }
        $usertoken = $DB->get_record('user', array('username' => $username));
        if (empty($usertoken)) {
            // Create user.
            $userdata = array(
                "username" => $username,
                "firstname" => $firstname,
                "lastname" => $lastname,
                "profile_field_".kronosportal_get_solutionfield() => $solutionid,
                "password" => $password,
                "email" => $email,
                "city" => $city,
                "country" => $country,
                "lang" => $language,
                "profile_field_learningpath" => $learningpath
            );
            $result = kronosportal_validate_user((object)$userdata, true);
            if ($result == 'success') {
                $user = kronosportal_create_user($userdata);
                return array(
                    'status' => 'success',
                    'userid' => $user->id
                );
            } else {
                throw new invalid_parameter_exception(get_string('webserviceerror'.$result, 'auth_kronosportal'));
            }
        } else {
            // User already exists.
            throw new invalid_parameter_exception(get_string('webserviceerroruserexists', 'auth_kronosportal'));
        }
    }

    /**
     * Returns description of create_user return value
     *
     * @return external_description
     */
    public static function create_user_returns() {
        return new external_single_structure(array(
            'status' => new external_value(PARAM_TEXT, 'Returns success when user is created.'),
            'userid' => new external_value(PARAM_INT, 'User id of updated user.'),
        ));
    }

    /**
     * Returns description of method parameters for update_user
     *
     * @return external_function_parameters
     */
    public static function update_user_parameters() {
        return new external_function_parameters(array(
            'username' => new external_value(PARAM_USERNAME, 'The username to update'),
            'firstname' => new external_value(PARAM_TEXT, 'First name'),
            'lastname' => new external_value(PARAM_TEXT, 'Last name'),
            'solutionid' => new external_value(PARAM_TEXT, 'Solution ID/Customer ID'),
            'password' => new external_value(PARAM_TEXT, 'Password'),
            'email' => new external_value(PARAM_EMAIL, 'Email'),
            'city' => new external_value(PARAM_TEXT, 'City', VALUE_DEFAULT),
            'country' => new external_value(PARAM_TEXT, 'Country', VALUE_DEFAULT),
            'language' => new external_value(PARAM_TEXT, 'Language', VALUE_DEFAULT),
            'learningpath' => new external_value(PARAM_TEXT, 'learningPath', VALUE_DEFAULT)
        ));
    }

    /**
     * Update a user.
     *
     * @throws moodle_exception On missing data or invalid user data.
     * @param string $username The username to update.
     * @return array Array with status equal to success and userid of updated record.
     */
    public static function update_user($username, $firstname, $lastname, $solutionid, $password,
            $email, $city = null, $country = null, $language = '', $learningpath = null) {
        global $DB, $CFG;
        if ($language == '') {
            $language = $CFG->lang;
        }
        $usertoken = $DB->get_record('user', array('username' => $username), '*');
        if (empty($usertoken)) {
            throw new invalid_parameter_exception(get_string('webserviceerrorinvaliduser', 'auth_kronosportal'));
        } else {
            // Update user.
            $userdata = array(
                "id" => $usertoken->id,
                "username" => $username,
                "firstname" => $firstname,
                "lastname" => $lastname,
                "profile_field_".kronosportal_get_solutionfield() => $solutionid,
                "password" => $password,
                "email" => $email
            );
            // Optional fields.
            if ($language !== null) {
                $userdata["lang"] = $language;
            }
            if ($city !== null) {
                $userdata["city"] = $city;
            }
            if ($country !== null) {
                $userdata["country"] = $country;
            }
            if ($learningpath !== null) {
                $userdata["profile_field_learningpath"] = $learningpath;
            }
            $result = kronosportal_validate_user((object)$userdata);
            if ($result == 'success') {
                $user = kronosportal_update_user($userdata);
                return array(
                    'status' => 'success',
                    'userid' => $user->id
                );
            } else {
                throw new invalid_parameter_exception(get_string('webserviceerror'.$result, 'auth_kronosportal'));
            }
        }
    }

    /**
     * Returns description of create_token return value
     *
     * @return external_description
     */
    public static function update_user_returns() {
        return new external_single_structure(array(
            'status' => new external_value(PARAM_TEXT, 'Returns success when user is updated.'),
            'userid' => new external_value(PARAM_INT, 'User id of updated user.'),
        ));
    }

    /**
     * Returns description of method parameters for logout_by_token
     *
     * @return external_function_parameters
     */
    public static function logout_by_token_parameters() {
        return new external_function_parameters(array(
            'token' => new external_value(PARAM_TEXT, 'The the token to delete and logout attached session'),
            'alltokens' => new external_value(PARAM_BOOL, 'Set to true to logout all tokens associated with user',
                    VALUE_DEFAULT, false)
        ));
    }

    /**
     * Logout session associated with token
     *
     * @throws moodle_exception On token invalid.
     * @param string $token Token associated with session to logout.
     * @param bool $alltokens If true logout all sessions associated with token.
     * @return array Array containing field status indicating success or error.
     */
    public static function logout_by_token($token, $alltokens = false) {
        global $DB;
        // Delete session records assoicated with token.
        try {
            $tokenrecord = $DB->get_record('kronosportal_tokens', array('token' => $token), '*', MUST_EXIST);
            $userid = $tokenrecord->userid;
        } catch (dml_missing_record_exception $ignored) {
            // Token was already destroyed.
            throw new invalid_parameter_exception(get_string('webserviceerrortokennotfound', 'auth_kronosportal'));
        }

        if ($alltokens) {
            // Delete all session records assoicated with user.
            try {
                $tokenrecords = $DB->get_records('kronosportal_tokens', array('userid' => $tokenrecord->userid));
                foreach ($tokenrecords as $token) {
                    self::logout_session($token->sid, $userid);
                }
                $DB->delete_records('kronosportal_tokens', array("userid" => $user->id));
            } catch (dml_missing_record_exception $ignored ) {
                throw new invalid_parameter_exception(get_string('webserviceerrortokennotfound', 'auth_kronosportal'));
            }
        } else {
            $DB->delete_records('kronosportal_tokens', array("token" => $token));
            if (!empty($tokenrecord->sid)) {
                self::logout_session($tokenrecord->sid, $userid);
            }
        }
        return array('status' => 'success');
    }

    /**
     * Returns description of logout_by_token return value
     *
     * @return external_description
     */
    public static function logout_by_token_returns() {
        return new external_single_structure(
            array(
            'status' => new external_value(PARAM_TEXT, 'Returns success when token and session is deleted. '.
                'When the token is not found and expection is thrown. '.
                'This occurs when a user logouts with the moodle logout button '.
                'before webservice is called.'),
        ));
    }

    /**
     * Returns description of method parameters for logout_by_user
     *
     * @return external_function_parameters
     */
    public static function logout_by_user_parameters() {
        return new external_function_parameters(array(
            'username' => new external_value(PARAM_TEXT, 'The the user to delete and logout attached session')
        ));
    }

    /**
     * Logout all sessions and tokens associated with user
     *
     * @param string $username Username associated with tokens to logout.
     * @return array Array containing field status indicating success or error.
     */
    public static function logout_by_user($username) {
        global $DB;

        $params = self::validate_parameters(self::logout_by_user_parameters(), array(
            'username' => $username
        ));

        try {
            $user = $DB->get_record('user', array('username' => $username), '*', MUST_EXIST);
        } catch (dml_missing_record_exception $ignored) {
            throw new invalid_parameter_exception(get_string('webserviceerrortokennotfound', 'auth_kronosportal'));
        }

        // Delete all session records assoicated with user.
        if (!empty($user->id)) {
            $tokenrecords = $DB->get_records('kronosportal_tokens', array('userid' => $user->id));
            if (count($tokenrecords) === 0) {
                throw new invalid_parameter_exception(get_string('webserviceerrortokennotfound', 'auth_kronosportal'));
            }
            foreach ($tokenrecords as $token) {
                self::logout_session($token->sid, $token->userid);
            }
            $DB->delete_records('kronosportal_tokens', array("userid" => $user->id));
        }

        return array('status' => 'success');
    }

    /**
     * Returns description of logout_by_user return value
     *
     * @return external_description
     */
    public static function logout_by_user_returns() {
        return new external_single_structure(
            array(
            'status' => new external_value(PARAM_TEXT, 'Returns success when token and session is deleted. '.
                'When the token is not found and expection is thrown. '.
                'This occurs when a user logouts with the moodle logout button '.
                'before webservice is called.'),
        ));
    }

    /**
     * Returns random token
     *
     * @return string token
     */
    public static function generate_token() {
        return md5(uniqid(rand(), 1));
    }

    /**
     * Logout out session
     *
     * @param string $sid Session id to logout
     * @param int $userid User id associated with session id to logout
     * @return void
     */
    private static function logout_session($sid, $userid) {
        global $DB;
        if (empty($sid)) {
            return;
        }
        $DB->delete_records('external_tokens', array('sid' => $sid, 'tokentype' => EXTERNAL_TOKEN_EMBEDDED));
        $event = \core\event\user_loggedout::create(
                array(
                    'userid' => $userid,
                    'objectid' => $userid,
                    'other' => array('sessionid' => $sid)
                )
        );
        $event->trigger();
        \core\session\manager::kill_session($sid);
    }
}
